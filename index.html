<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Stealth Crypto Maze</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      background: #050811;
      color: #f5f5f5;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      min-height: 100vh;
      padding: 16px;
      gap: 16px;
    }

    h1 {
      font-size: 1.8rem;
      letter-spacing: 0.05em;
      text-align: center;
      background: linear-gradient(90deg, #c6f247, #4dd2ff);
      -webkit-background-clip: text;
      color: transparent;
      margin-bottom: 4px;
    }

    .subtitle {
      font-size: 0.95rem;
      color: #b5bed8;
      text-align: center;
      max-width: 700px;
    }

    #game-container {
      background: radial-gradient(circle at top, #202742, #050811 60%);
      border-radius: 16px;
      padding: 16px;
      box-shadow: 0 0 30px rgba(0, 0, 0, 0.7);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }

    canvas {
      background: #050811;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      max-width: 90vw;
      max-height: 90vw;
    }

    .hud {
      display: flex;
      gap: 16px;
      justify-content: center;
      align-items: center;
      font-size: 0.9rem;
      color: #e6ebff;
    }

    .hud span.label {
      color: #8b94b2;
    }

    #score {
      font-weight: 600;
      color: #c6f247;
    }

    #message {
      min-height: 22px;
      font-size: 0.95rem;
      text-align: center;
      color: #f5f5f5;
    }

    #message span.win {
      color: #c6f247;
      font-weight: 600;
    }

    #message span.lose {
      color: #ff5c7a;
      font-weight: 600;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      justify-content: center;
      margin-top: 2px;
    }

    button {
      background: linear-gradient(135deg, #283352, #101625);
      color: #e6ebff;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      padding: 6px 14px;
      font-size: 0.85rem;
      cursor: pointer;
      transition: transform 0.08s ease, box-shadow 0.08s ease, border-color 0.08s ease, background 0.08s ease;
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 0 12px rgba(198, 242, 71, 0.25);
      border-color: #c6f247;
      background: linear-gradient(135deg, #303d63, #151c30);
    }

    button:active {
      transform: translateY(0px) scale(0.98);
      box-shadow: none;
    }

    .hint {
      font-size: 0.8rem;
      color: #8b94b2;
      text-align: center;
      max-width: 520px;
      line-height: 1.4;
    }

    .hint code {
      background: rgba(255, 255, 255, 0.06);
      padding: 2px 5px;
      border-radius: 4px;
      font-size: 0.78rem;
    }

    #leaderboard-container {
      margin-top: 10px;
      background: rgba(5, 8, 17, 0.8);
      border-radius: 12px;
      padding: 10px 14px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      max-width: 720px;
      width: 100%;
    }

    #leaderboard-container h2 {
      font-size: 0.95rem;
      margin-bottom: 6px;
      color: #c6f247;
    }

    #leaderboard-list {
      list-style: none;
      font-size: 0.85rem;
      color: #e6ebff;
      padding-left: 0;
    }

    #leaderboard-list li {
      display: flex;
      justify-content: space-between;
      padding: 2px 0;
      border-bottom: 1px dashed rgba(255, 255, 255, 0.06);
    }

    #leaderboard-list li span.name {
      max-width: 60%;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    #leaderboard-list li span.score {
      color: #c6f247;
      font-weight: 600;
      margin-left: 10px;
    }

    @media (max-width: 600px) {
      h1 {
        font-size: 1.4rem;
      }
      .subtitle {
        font-size: 0.85rem;
      }
    }
  </style>
</head>
<body>
  <h1>Stealth Crypto Maze</h1>
  <p class="subtitle">
    Sneak your crypto token from one wallet to another without getting spotted by roving eyes.
  </p>

  <div id="game-container">
    <canvas id="game" width="720" height="720"></canvas>

    <div class="hud">
      <div><span class="label">Score:</span> <span id="score">0</span></div>
      <div><span class="label">Keys:</span> WASD or Arrow Keys • R reset • N new maze</div>
    </div>

    <div id="message"></div>

    <div class="controls">
      <button id="newMazeBtn">New Maze</button>
      <button id="resetBtn">Reset Token</button>
    </div>
  </div>

  <div id="leaderboard-container">
    <h2>Leaderboard</h2>
    <ol id="leaderboard-list"></ol>
  </div>

  <p class="hint">
    Move with <code>WASD</code> or <code>Arrow Keys</code>. Collect dots for points and avoid the glowing scan zones.
    Reach the exit wallet to complete a private transfer and save your score.
  </p>

  <script>
    (function () {
      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d');
      const messageEl = document.getElementById('message');
      const newMazeBtn = document.getElementById('newMazeBtn');
      const resetBtn = document.getElementById('resetBtn');
      const scoreEl = document.getElementById('score');
      const leaderboardList = document.getElementById('leaderboard-list');
      // ===== Global Leaderboard (Supabase) =====
// GitHub Pages is static. To get a shared leaderboard, we use Supabase (hosted database).
// 1) Paste your Supabase Project URL + anon key here:
const SUPABASE_URL = "https://xngzwbosbtzjhvelhoqb.supabase.co";
const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InhuZ3p3Ym9zYnR6amh2ZWxob3FiIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjU5OTI5MjksImV4cCI6MjA4MTU2ODkyOX0.wsenjkwKbX4K2jTC9xTnw-FFStLtuMCxsAfPPIn9NRk";
const SUPABASE_TABLE = "maze_leaderboard";

// Keep localStorage as a fallback if Supabase isn't configured yet.
const LEADERBOARD_KEY = 'stealthCryptoMazeLeaderboard';

function sbConfigured() {
  return SUPABASE_URL && SUPABASE_ANON_KEY &&
    !SUPABASE_URL.includes("PUT_YOUR_") && !SUPABASE_ANON_KEY.includes("PUT_YOUR_");
}

function sbHeaders() {
  return {
    "apikey": SUPABASE_ANON_KEY,
    "Authorization": `Bearer ${SUPABASE_ANON_KEY}`,
    "Content-Type": "application/json",
  };
}

async function fetchLeaderboardTop10() {
  const url = `${SUPABASE_URL}/rest/v1/${SUPABASE_TABLE}?select=name,score,created_at&order=score.desc,created_at.asc&limit=10`;
  const res = await fetch(url, { headers: sbHeaders() });
  if (!res.ok) throw new Error(`Leaderboard fetch failed: ${res.status}`);
  return await res.json();
}

async function submitScoreOnline({ name, score, referral_code }) {
  const url = `${SUPABASE_URL}/rest/v1/${SUPABASE_TABLE}`;
  const payload = [{
    name,
    score,
    referral_code: referral_code || null,
  }];

  const res = await fetch(url, {
    method: "POST",
    headers: { ...sbHeaders(), "Prefer": "return=minimal" },
    body: JSON.stringify(payload),
  });

  if (!res.ok) throw new Error(`Score submit failed: ${res.status}`);
}

function loadLeaderboard() {
  try {
    const raw = localStorage.getItem(LEADERBOARD_KEY);
    if (!raw) return [];
    const data = JSON.parse(raw);
    return Array.isArray(data) ? data : [];
  } catch (e) {
    return [];
  }
}

function saveLeaderboard(lb) {
  try {
    localStorage.setItem(LEADERBOARD_KEY, JSON.stringify(lb));
  } catch (e) {
    // ignore
  }
}

async function refreshLeaderboardUI() {
  if (!sbConfigured()) {
    // Not configured yet, show local leaderboard so the game still works.
    renderLeaderboard(loadLeaderboard());
    return;
  }
  try {
    const lb = await fetchLeaderboardTop10();
    renderLeaderboard(lb);
  } catch (e) {
    console.warn(e);
    // fallback to local
    renderLeaderboard(loadLeaderboard());
  }
}
// =======================================

      function renderLeaderboard(lb) {
        leaderboardList.innerHTML = '';
        if (!lb.length) {
          const li = document.createElement('li');
          li.textContent = 'No scores yet. Finish a run to claim a spot.';
          leaderboardList.appendChild(li);
          return;
        }
        lb.forEach((entry, idx) => {
          const li = document.createElement('li');
          const nameSpan = document.createElement('span');
          nameSpan.className = 'name';
          nameSpan.textContent = `${idx + 1}. ${entry.name || 'Anon'}`;
          const scoreSpan = document.createElement('span');
          scoreSpan.className = 'score';
          scoreSpan.textContent = entry.score;
          li.appendChild(nameSpan);
          li.appendChild(scoreSpan);
          leaderboardList.appendChild(li);
        });
      }

      refreshLeaderboardUI();

      function createGrid() {
        grid = [];
        for (let r = 0; r < rows; r++) {
          const row = [];
          for (let c = 0; c < cols; c++) {
            row.push({
              r,
              c,
              visited: false,
              walls: { top: true, right: true, bottom: true, left: true }
            });
          }
          grid.push(row);
        }
      }

      function neighbors(cell) {
        const res = [];
        const { r, c } = cell;
        if (r > 0) res.push(grid[r - 1][c]);
        if (r < rows - 1) res.push(grid[r + 1][c]);
        if (c > 0) res.push(grid[r][c - 1]);
        if (c < cols - 1) res.push(grid[r][c + 1]);
        return res;
      }

      function removeWalls(a, b) {
        const dr = b.r - a.r;
        const dc = b.c - a.c;
        if (dr === -1 && dc === 0) {
          a.walls.top = false;
          b.walls.bottom = false;
        } else if (dr === 1 && dc === 0) {
          a.walls.bottom = false;
          b.walls.top = false;
        } else if (dr === 0 && dc === -1) {
          a.walls.left = false;
          b.walls.right = false;
        } else if (dr === 0 && dc === 1) {
          a.walls.right = false;
          b.walls.left = false;
        }
      }

      // Depth first search maze generator
      function generateMaze() {
        createGrid();
        const stack = [];
        const startCell = grid[start.r][start.c];
        startCell.visited = true;
        stack.push(startCell);

        while (stack.length > 0) {
          const current = stack[stack.length - 1];
          const unvisited = neighbors(current).filter(n => !n.visited);
          if (unvisited.length === 0) {
            stack.pop();
          } else {
            const next = unvisited[Math.floor(Math.random() * unvisited.length)];
            removeWalls(current, next);
            next.visited = true;
            stack.push(next);
          }
        }

        // Reset visited flags
        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            grid[r][c].visited = false;
          }
        }
      }

      function availableDirections(r, c) {
        const cell = grid[r][c];
        const dirs = [];
        if (!cell.walls.top && r > 0) dirs.push('up');
        if (!cell.walls.right && c < cols - 1) dirs.push('right');
        if (!cell.walls.bottom && r < rows - 1) dirs.push('down');
        if (!cell.walls.left && c > 0) dirs.push('left');
        return dirs;
      }

      function moveFrom(r, c, dir) {
        if (dir === 'up') return { r: r - 1, c };
        if (dir === 'down') return { r: r + 1, c };
        if (dir === 'left') return { r, c: c - 1 };
        if (dir === 'right') return { r, c: c + 1 };
        return { r, c };
      }

      function randomElement(arr) {
        return arr[Math.floor(Math.random() * arr.length)];
      }

      // Eyes can spawn anywhere (except start/exit) and roam freely through walls
      function placeEyes() {
        eyes = [];
        let attempts = 0;
        const DIRS = ['up', 'down', 'left', 'right'];
        while (eyes.length < eyesCount && attempts < 1000) {
          attempts++;
          const r = Math.floor(Math.random() * rows);
          const c = Math.floor(Math.random() * cols);
          if ((r === start.r && c === start.c) || (r === exit.r && c === exit.c)) continue;
          if (eyes.some(e => e.r === r && e.c === c)) continue;
          eyes.push({ r, c, dir: randomElement(DIRS) });
        }
      }

      function placeDots() {
        dots = [];
        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            if ((r === start.r && c === start.c) || (r === exit.r && c === exit.c)) continue;
            if (Math.random() < DOT_PROBABILITY) {
              dots.push({ r, c, collected: false });
            }
          }
        }
      }

      function getDotAt(r, c) {
        return dots.find(d => d.r === r && d.c === c && !d.collected);
      }

      function collectDotIfAny() {
        const dot = getDotAt(player.r, player.c);
        if (dot) {
          dot.collected = true;
          score += DOT_SCORE;
          updateScoreDisplay();
        }
      }

      function resetPlayer() {
        player.r = start.r;
        player.c = start.c;
      }

      function updateScoreDisplay() {
        scoreEl.textContent = score;
      }

      function resetGame(newMaze = true) {
        gameState = 'playing';
        setMessage('Use the maze to shield your token from prying eyes.');
        if (newMaze) {
          generateMaze();
          score = 0;
          updateScoreDisplay();
        }
        resetPlayer();
        placeEyes();
        placeDots();
      }

      function setMessage(text, type) {
        if (!type) {
          messageEl.innerHTML = text;
          return;
        }
        const cls = type === 'win' ? 'win' : 'lose';
        messageEl.innerHTML = `<span class="${cls}">${text}</span>`;
      }

      function canMovePlayer(dir) {
        const cell = grid[player.r][player.c];
        if (dir === 'up') return !cell.walls.top && player.r > 0;
        if (dir === 'down') return !cell.walls.bottom && player.r < rows - 1;
        if (dir === 'left') return !cell.walls.left && player.c > 0;
        if (dir === 'right') return !cell.walls.right && player.c < cols - 1;
        return false;
      }

      function handleMove(dir) {
        if (gameState !== 'playing') return;
        if (!canMovePlayer(dir)) return;
        if (dir === 'up') player.r--;
        if (dir === 'down') player.r++;
        if (dir === 'left') player.c--;
        if (dir === 'right') player.c++;

        collectDotIfAny();

        if (player.r === exit.r && player.c === exit.c) {
          gameState = 'won';
          score += EXIT_BONUS;
          updateScoreDisplay();
          setMessage('Transfer complete. Your tokens moved privately. Score: ' + score, 'win');
          setTimeout(async () => {
            const name = (prompt('Enter your name for the leaderboard:', 'Anon') || '').trim().slice(0, 20);
            if (name) {
              const referral = (prompt('Pointless Referral Code (optional):', '') || '').trim().slice(0, 32);

              // Always save locally so players don't lose their score even if offline.
              leaderboard = loadLeaderboard();
              leaderboard.push({ name, score, date: Date.now() });
              leaderboard.sort((a, b) => b.score - a.score);
              leaderboard = leaderboard.slice(0, 10);
              saveLeaderboard(leaderboard);

              // Try to submit online + refresh the global board.
              if (sbConfigured()) {
                try {
                  await submitScoreOnline({ name, score, referral_code: referral || null });
                } catch (e) {
                  console.warn(e);
                  // keep going; local save already happened
                }
              }
              await refreshLeaderboardUI();
            }
          }, 150);
        }
      }

      document.addEventListener('keydown', (e) => {
        let dir = null;
        if (['ArrowUp', 'KeyW'].includes(e.code)) dir = 'up';
        if (['ArrowDown', 'KeyS'].includes(e.code)) dir = 'down';
        if (['ArrowLeft', 'KeyA'].includes(e.code)) dir = 'left';
        if (['ArrowRight', 'KeyD'].includes(e.code)) dir = 'right';

        if (dir) {
          e.preventDefault();
          handleMove(dir);
        }

        if (e.code === 'KeyR') {
          e.preventDefault();
          resetGame(false);
        }
        if (e.code === 'KeyN') {
          e.preventDefault();
          resetGame(true);
        }
      });

      newMazeBtn.addEventListener('click', () => resetGame(true));
      resetBtn.addEventListener('click', () => resetGame(false));

      // Eyes ignore maze walls; they roam the whole grid and bounce off borders
      function updateEyes(delta) {
        if (gameState !== 'playing') return;
        lastEyeStep += delta;
        if (lastEyeStep < eyeStepInterval) return;
        lastEyeStep = 0;

        for (const eye of eyes) {
          // occasionally change direction randomly
          if (Math.random() < 0.3) {
            const dirs = ['up', 'down', 'left', 'right'];
            eye.dir = randomElement(dirs);
          }

          let next = moveFrom(eye.r, eye.c, eye.dir);

          // bounce off borders
          if (next.r < 0 || next.r >= rows || next.c < 0 || next.c >= cols) {
            if (eye.dir === 'up') eye.dir = 'down';
            else if (eye.dir === 'down') eye.dir = 'up';
            else if (eye.dir === 'left') eye.dir = 'right';
            else if (eye.dir === 'right') eye.dir = 'left';

            next = moveFrom(eye.r, eye.c, eye.dir);
            next.r = Math.max(0, Math.min(rows - 1, next.r));
            next.c = Math.max(0, Math.min(cols - 1, next.c));
          }

          eye.r = next.r;
          eye.c = next.c;
        }
      }

      function checkDetection() {
        if (gameState !== 'playing') return;
        for (const eye of eyes) {
          const dr = eye.r - player.r;
          const dc = eye.c - player.c;
          const dist = Math.sqrt(dr * dr + dc * dc);
          if (dist <= detectionRadiusCells - 0.05) {
            gameState = 'lost';
            setMessage('You were spotted. Privacy breached. Try again.', 'lose');
            return;
          }
        }
      }

      function drawMaze() {
        ctx.strokeStyle = '#101425';
        ctx.lineWidth = 2;
        ctx.lineCap = 'round';
        ctx.beginPath();
        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            const cell = grid[r][c];
            const x = c * cellSize;
            const y = r * cellSize;
            if (cell.walls.top) {
              ctx.moveTo(x, y);
              ctx.lineTo(x + cellSize, y);
            }
            if (cell.walls.right) {
              ctx.moveTo(x + cellSize, y);
              ctx.lineTo(x + cellSize, y + cellSize);
            }
            if (cell.walls.bottom) {
              ctx.moveTo(x, y + cellSize);
              ctx.lineTo(x + cellSize, y + cellSize);
            }
            if (cell.walls.left) {
              ctx.moveTo(x, y);
              ctx.lineTo(x, y + cellSize);
            }
          }
        }
        ctx.stroke();
      }

      function roundRect(ctx, x, y, w, h, r) {
        const radius = Math.min(r, w / 2, h / 2);
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.lineTo(x + w - radius, y);
        ctx.quadraticCurveTo(x + w, y, x + w, y + radius);
        ctx.lineTo(x + w, y + h - radius);
        ctx.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
        ctx.lineTo(x + radius, y + h);
        ctx.quadraticCurveTo(x, y + h, x, y + h - radius);
        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();
      }

      function drawWallet(r, c, isExit) {
        const x = c * cellSize + cellSize / 2;
        const y = r * cellSize + cellSize / 2;
        const w = cellSize * 0.5;
        const h = cellSize * 0.35;
        const radius = 6;

        ctx.save();
        ctx.translate(x - w / 2, y - h / 2);

        // Wallet body
        const grad = ctx.createLinearGradient(0, 0, w, h);
        if (isExit) {
          grad.addColorStop(0, '#00e0ff');
          grad.addColorStop(1, '#4d7bff');
        } else {
          grad.addColorStop(0, '#c6f247');
          grad.addColorStop(1, '#6dea6d');
        }
        ctx.fillStyle = grad;
        roundRect(ctx, 0, 0, w, h, radius);
        ctx.fill();

        // Flap
        ctx.fillStyle = 'rgba(0, 0, 0, 0.18)';
        roundRect(ctx, 0, 0, w * 0.35, h, radius);
        ctx.fill();

        // Clasp
        ctx.fillStyle = 'rgba(0, 0, 0, 0.55)';
        ctx.beginPath();
        ctx.arc(w * 0.33, h * 0.5, h * 0.09, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
      }

      function drawPlayer() {
        const x = player.c * cellSize + cellSize / 2;
        const y = player.r * cellSize + cellSize / 2;
        const radius = cellSize * 0.23;

        const grad = ctx.createRadialGradient(
          x - radius * 0.3,
          y - radius * 0.3,
          radius * 0.2,
          x,
          y,
          radius
        );
        grad.addColorStop(0, '#ffe480');
        grad.addColorStop(0.5, '#ffc43b');
        grad.addColorStop(1, '#ff9c1a');

        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();

        // Simple crypto symbol
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.6)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x - radius * 0.4, y);
        ctx.lineTo(x + radius * 0.4, y);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(x, y - radius * 0.4);
        ctx.lineTo(x, y + radius * 0.4);
        ctx.stroke();
      }

      function drawEyes() {
        for (const eye of eyes) {
          const x = eye.c * cellSize + cellSize / 2;
          const y = eye.r * cellSize + cellSize / 2;
          const detectionRadius = detectionRadiusCells * cellSize;

          // Detection zone
          ctx.save();
          ctx.globalAlpha = 0.12;
          ctx.fillStyle = '#ff5c7a';
          ctx.beginPath();
          ctx.arc(x, y, detectionRadius, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();

          // Eye white
          ctx.fillStyle = '#f5f7ff';
          ctx.beginPath();
          ctx.arc(x, y, cellSize * 0.22, 0, Math.PI * 2);
          ctx.fill();

          // Outline
          ctx.strokeStyle = '#ff5c7a';
          ctx.lineWidth = 2;
          ctx.stroke();

          // Pupil
          let dx = 0, dy = 0;
          if (eye.dir === 'up') dy = -1;
          else if (eye.dir === 'down') dy = 1;
          else if (eye.dir === 'left') dx = -1;
          else if (eye.dir === 'right') dx = 1;

          const pupilOffset = cellSize * 0.07;
          const px = x + dx * pupilOffset;
          const py = y + dy * pupilOffset;

          ctx.fillStyle = '#050811';
          ctx.beginPath();
          ctx.arc(px, py, cellSize * 0.09, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      function drawDots() {
        ctx.fillStyle = '#c6f247';
        for (const d of dots) {
          if (d.collected) continue;
          const x = d.c * cellSize + cellSize / 2;
          const y = d.r * cellSize + cellSize / 2;
          ctx.beginPath();
          ctx.arc(x, y, cellSize * 0.08, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Background
        ctx.fillStyle = '#050811';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        drawMaze();
        drawDots();
        drawWallet(start.r, start.c, false);
        drawWallet(exit.r, exit.c, true);
        drawEyes();
        drawPlayer();
      }

      let lastTimestamp = 0;

      function loop(timestamp) {
        const delta = timestamp - lastTimestamp;
        lastTimestamp = timestamp;

        updateEyes(delta);
        checkDetection();
        render();

        requestAnimationFrame(loop);
      }

      // Init
      score = 0;
      updateScoreDisplay();
      resetGame(true);
      requestAnimationFrame(loop);
    })();
  </script>
</body>
</html>
